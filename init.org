#+TITLE: Emacs Configuration
#+AUTHOR:Shayan Azmoodeh
#+PROPERTY: header-args:emacs-lisp :tangle ~/.emacs.d/init.el :results none

* Character Encoding Scheme

The default character coding scheme for documents written in Emacs is UTF-8. Code ensures that all typing and reading of files is done with UTF-8.

#+name: set-encoding-system
#+begin_src emacs-lisp
  ;; setting encoding system
  (prefer-coding-system       'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (setq default-buffer-file-coding-system 'utf-8)              
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))
#+end_src

* Emacs Generated Settings

Emacs generates its own set of settings from the init file. We want these to be separate from our own config code, so we tell Emacs to write it in a separate file called "custom.el".

#+name: custom-settings-file
#+begin_src emacs-lisp
  ;; move Emacs generated settings to separate file
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p custom-file)
    (load custom-file))
#+end_src

* UI Configurations
** Fonts

Emacs has fixed and variable pitch fonts. Fixed pitch fonts are fonts with fixed width characters and is commonly used for code while variable pitch fonts consist of characters of different widths and are used for word processors (makes text feel more natural).

We set the default font for each of these classes which can be set as the default =face-attribute= in any mode.

#+name: set-face-attributes
#+begin_src emacs-lisp
    ;; font size/style

    (setq fixed-pitch-font "DejaVu Sans Mono"
          variable-pitch-font "Cambria")

    (set-face-attribute 'default nil
                        :font fixed-pitch-font
                        :height 130)
    ;; set fixed pitch face font
    (set-face-attribute 'fixed-pitch nil
                        :font fixed-pitch-font
                        :height 130)
    ;; set the variable pitch face font
    (set-face-attribute 'variable-pitch nil
                        :font variable-pitch-font
                        :height 130
                        :weight 'regular)
#+end_src

#+RESULTS: set-face-attributes

** Line Numbers

Like other code editors, we want to see the line numbers on the left side of the screen when editing code.

#+name: enable-line-numbers
#+begin_src emacs-lisp
  ;; showing line numbers
  (column-number-mode)
  (global-display-line-numbers-mode)
#+end_src

However, we don't want line numbers in modes that are not for code editing (i.e. org-mode, terminal/shell mode, etc.). We disable line numbers in these modes.

#+name: disable-line-numbers-certain-modes
#+begin_src emacs-lisp
  ;; disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode -1))))
#+end_src

**  Keyboard Centric UI

Although we want to mainly use the keyboard, it would be nice to also have access to the mouse when working with Emacs in the terminal.

#+name: enable-mouse-terminal
#+begin_src emacs-lisp
  ;; allows using the mouse in terminal
  (xterm-mouse-mode 1)
#+end_src

To make Emacs's UI less distracting and encourage us to use the keyboard to control what happens in the system, we disable /the toolbar/ (that usually appears at the top of the screen), the /menu bar/, and the /scroll bar. /Also prevent /dialog boxes/ from showing up (i.e, pop-ups that ask for confirmation on-screen).

#+name: enable-keyboard-centric
#+begin_src emacs-lisp
  ;; Keyboard-centric user interface
  (tool-bar-mode -1)
  (tooltip-mode -1)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (set-fringe-mode 10)
  ; Don't display pop-up UI prompts
  (setq use-dialog-box nil)
#+end_src

#+RESULTS: enable-keyboard-centric

** Miscellaneous
Setting miscellaneous UI configurations.

#+name: no-splash-startup
#+begin_src emacs-lisp
  ;; Don't show the splash startup screen
  (setq inhibit-startup-message t)
#+end_src

Set the cursor to not blink and have Emacs highlight the line our cursor is currently on.

#+name: other-visual-stuff
#+begin_src emacs-lisp
  (blink-cursor-mode -1)
  (global-hl-line-mode 1)
#+end_src

We also automatically update buffers as they are being updated. No need to reload a buffer after making changes to the file in another program to see the changes.

#+begin_src emacs-lisp
  ;; auto update buffers when files updated on drive
  (global-auto-revert-mode 1)
#+end_src

* History

Emacs can store recently visited files and a history of commands typed in minibuffer. We configure Emacs to save these histories.

/Note: View list of recently accessed files with the =M-x recentf-open-files= command/.

#+name: enable-save-history
#+begin_src emacs-lisp
  ;; show recent files (M-x recentf-open-files)
  (recentf-mode 1)

  ;; remember and restore last cursor location of opened files
  (save-place-mode 1)

  ;; save what you enter into minibuffer prompts
  (setq history-length 25)
  (savehist-mode 1)
#+end_src

* Packages
** Set Up
Set-up the locations to fetch packages from and also intialize the /use-package/ package to simplify requiring future packages.
- Note we first have to =(require package)= to be able to install =use-package=. _We do not use the =package= ever again_.

#+name: setup-use-package
#+begin_src emacs-lisp
  ;;; packages

  ;; Define and initialize package repositories (MELPA/ELPA)
  (require 'package)
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("org" . "https://orgmode.org/elpa/")
                           ("elpa" . "https://elpa.gnu.org/packages/")))
  (package-initialize)

  ;; use use-package to simplify loading packages
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (require 'use-package)
  (setq use-package-always-ensure t)

#+end_src

** Convenience
*** Which Key

=which-key= supplies us with a /cheatsheet/ for keybindings. If you enter part of a keybinding and do not remember what to do next, a buffer pops up showing possible completions.

#+name: use-package-which-key
#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.5
          which-key-idle-secondary-delay 0.5)
    (which-key-setup-side-window-bottom))
#+end_src

Change the value of =which-key-idle-delay= to control how long the program waits after you enter the first key until it shows the cheatsheet.

- The =:diminish= option prevents the mode name from showing up in the modeline (at the bottom of the screen)
  - Keeps UI cleaner
    
*** No Littering

=no-littering= simply cleans up the =~/.emacs.d/= directory and organizes all extraneous files that I don't need to care about into directories.

    #+name: use-package-no-littering
    #+begin_src emacs-lisp
      (use-package no-littering)
    #+end_src

*** Helpful
=helpful= gives better help pages when you view the documentation for a symbol.

#+begin_src emacs-lisp
  ;; better help pages
  (use-package helpful
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key)
  )
#+end_src

** Completion Packages
*** Ivy
Ivy is a completion engine that enables /fuzzy search/ of the list to search. It is used to search things when you open the buffer list, action list (with =M-x=), and many other things.

#+name: use-package-ivy
#+begin_src emacs-lisp
  (use-package ivy
    :bind (("C-s" . swiper)
           :map ivy-minibuffer-map
           ("TAB" . ivy-alt-done)
           ("C-l" . ivy-alt-done)
           ("C-n" . ivy-next-line)
           ("C-p" . ivy-previous-line)
           :map ivy-switch-buffer-map
           ("C-p" . ivy-previous-line)
           ("C-l" . ivy-done)
           ("C-d" . ivy-switch-buffer-kill)
           :map ivy-reverse-i-search-map
           ("C-p" . ivy-previous-line)
           ("C-d" . ivy-reverse-i-search-kill))
    :config
    (ivy-mode 1))
#+end_src

Ivy also have many other packages that go along with it to make it work in other contexts.

**** Counsel

Counsel uses Ivy as its backend to complete certain languages at point (i.e. emacs lisp) and also complete command names when the list is opened with =M-x=.
We are remapping =M-x= to run =counsel-M-x= which is the same as the regular command list but allows us to use the fuzzy search and other features provided by counsel/ivy). Similarly we set the keybindings to open =counsel-ibuffer= instead of the usual buffer list.

#+name: use-package-counsel
#+begin_src emacs-lisp
  (use-package counsel
    :after ivy
    :bind (("M-x" . counsel-M-x)
           ("C-x b" . counsel-ibuffer)
           :map minibuffer-local-map
           ("C-r" . 'counsel-minibuffer-history))
    :config
    (setq ivy-initial-inputs-alist nil))

#+end_src

We use the ivy-rich package to give short descriptions for commands when =counsel-M-x= is run.

#+name: use-package-ivy-rich
#+begin_src emacs-lisp
  ;; give description of commands in counsel-M-x
  (use-package ivy-rich
    :after ivy counsel
    :init
    (ivy-rich-mode 1))

#+end_src
*** Company

Company is a completion system for autocompleting typed text in the current buffer. It uses other words in all open buffers to suggest completions as you type.

(I'm pretty sure company does not use Ivy as a backend)

We also need to have the =popup= package so company has a way to display the autocomplete recommendations.

#+name: use-package-company
#+begin_src emacs-lisp
  (use-package popup)

  ;; Auto completion of words
  (use-package company
    :after popup
    :config
    (setq company-idle-delay 0
          ;; minimum word length before it gives suggestions
          company-minimum-prefix-length 4
          company-selection-wrap-around t))
  (global-company-mode)
#+end_src
*** Smartparens

Smartparens gives us automatic parenthesis matching. Also works with ={}, [], ""= , etc.

#+begin_src emacs-lisp
  ;; auto parenthesis matching
  (use-package smartparens
    :init
    (require 'smartparens-config)
    :config
    (setq prog-mode smartparens-strict-mode))
  (smartparens-global-mode t)
#+end_src

** UI Packages
Most of the UI related packages require =all-the-icons=. It's used to display graphic things and fonts.

#+name: use-package-all-the-icons
#+begin_src emacs-lisp
  (use-package all-the-icons
    :if (display-graphic-p))
#+end_src

Make sure to run =M-x all-the-icons-install-fonts= after installing for everything to work correctly.

*** Centaur Tabs

Centaur tabs gives us /tabs in emacs/ and makes it look more like a traditional text editor. There's a lot of configuration options to it's best to look at the [[https://github.com/ema2159/centaur-tabs][documentation]] for help with configuring it.

#+name:use-package-centaur-tabs
#+begin_src emacs-lisp
  ;; Tabs
  (use-package centaur-tabs
    :after evil
    :init
    (setq centaur-tabs-enable-key-bindings t)
    :demand
    :config
    (centaur-tabs-mode t)
    (setq centaur-tabs-style "bar"
          centaur-tabs-height 32
          centaur-tabs-set-icons t
          centaur-tabs-set-modified-marker t
          centaur-tabs-show-navigation-buttons t
          centaur-tabs-set-bar 'under
          x-underline-at-descent-line t
          centaur-tabs-modified-marker "●")
    (centaur-tabs-headline-match)
    (centaur-tabs-change-fonts variable-pitch-font 150)
    (setq uniquify-separator "/")
    (setq uniquify-buffer-name-style 'forward)
    :hook
    (dashboard-mode . centaur-tabs-local-mode)
    (term-mode . centaur-tabs-local-mode)
    (calendar-mode . centaur-tabs-local-mode)
    (org-agenda-mode . centaur-tabs-local-mode)
    (helpful-mode . centaur-tabs-local-mode)
    :bind
    ("C-<prior>" . centaur-tabs-backward)
    ("C-<next>" . centaur-tabs-forward)
    ("C-c t s" . centaur-tabs-counsel-switch-group)
    ("C-c t p" . centaur-tabs-group-by-projectile-project)
    ("C-c t g" . centaur-tabs-group-buffer-groups)
    (:map evil-normal-state-map
          ("g t" . centaur-tabs-forward)
          ("g T" . centaur-tabs-backward)))
#+end_src

*** Doom
**** Doom Modeline

Doom modeline makes the modeline look better. That's it.

#+name: use-package-doom-modeline
#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom ((doom-modeline-height 15)))
#+end_src

**** Doom Themes

Selecting a Doom theme to make Emacs look better. See [[https://github.com/doomemacs/themes/tree/screenshots][list of themes]] to choose one.

#+name: use-package-doom-themes
#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    ;; Global settings (defaults)
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
          doom-themes-enable-italic t) ; if nil, italics is universally disabled
    (load-theme 'doom-material t)

    ;; Enable flashing mode-line on errors
    (doom-themes-visual-bell-config)
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))
#+end_src

*** Rainbow Delimiters

Colors parenthesis and other delimiters so matching delimiters are the same color.

#+name:use-package-rainbow-delimiters
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Evil

Evil (Emacs Vim Layer) is a layer of Vim on top of Emacs. Basically I've configured it to just give Emacs different editing modes like Vim and to use Vim keybindings when in the "Normal state". When in "Insert State" it uses regular Emacs keybindings (I didn't want to learn an entirely new set of keybindings).

#+name: emacs-keybind-insert-state
#+begin_src emacs-lisp
  ;; use emacs keybinding when editing files (insert mode)
  (setq evil-disable-insert-state-bindings t)
#+end_src

#+name: use-package-evil
#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-want-C-u-scroll t)
    (setq evil-want-C-i-jump nil)
    :config
    (evil-mode 1)
    (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
    (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    ;; Use visual line motions even outside of visual-line-mode buffers
    (evil-global-set-key 'motion "j" 'evil-next-visual-line)
    (evil-global-set-key 'motion "k" 'evil-previous-visual-line)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

Evil collection give vim keybindings in many of the available modes that Evil does not natively support.

#+begin_src emacs-lisp
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** Magit

Magit is like a git GUI but runs in Emacs.

#+name: use-package-magit
#+begin_src emacs-lisp
  (use-package magit
    :commands (magit-status magit-get-current-branch)
    :custom
    ;; show diff in same window
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

Pushing to a remote repository does not always prompt for a password and thus fails. The =ssh-agency= package fixes that.

#+name: use-package-ssh-agency
#+begin_src emacs-lisp
  ;; make magit prompt for ssh password
  (use-package ssh-agency)
  (setenv "SSH_ASKPASS" "git-gui--askpass")
#+end_src

** Org Mode
Org mode is what I am using to type this document. It is a plaintext markdown format that is very versatile and can do many things other than just produce nice documents.

I implemented multiple functions to simplify the configuration of =org=.

#+name:org-config-funcs
#+begin_src emacs-lisp :results none
  (defun ska/org-font-setup ()
    ;; Replace list hyphen with dot
    (font-lock-add-keywords 'org-mode
                            '(("^ *\\([-]\\) "
                               (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•")))))))

  (defun ska/org-mode-setup ()
    "Set up org mode"
    (org-indent-mode)
    (variable-pitch-mode 1)
    (visual-line-mode 1)
    ;; scale font size of headers
    (dolist (face '((org-level-1 . 1.2)
                    (org-level-2 . 1.1)
                    (org-level-3 . 1.05)
                    (org-level-4 . 1.0)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1)))
      (set-face-attribute (car face) nil
                          :font variable-pitch-font
                          :weight 'regular
                          :height (cdr face))))

  (defun ska/org-mode-toggle-hide-emphasis-markers ()
    "Toggle org mode emphasis markers on and off"
    (interactive)
    (progn (if (null org-hide-emphasis-markers)
               (setq org-hide-emphasis-markers t)
             (setq org-hide-emphasis-markers nil))
           (org-mode)))
#+end_src

Change the =org-directory= if the location of org-roam files changes.

#+name: use-package-org
#+begin_src emacs-lisp :results none
  (use-package org
    :hook (org-mode . ska/org-mode-setup)
    :config
    (setq org-ellipsis " ▾")
    (ska/org-font-setup)
    :bind (
           ;; toggle org mode emphasis markers on and off
           ("C-c s e" . ska/org-mode-toggle-hide-emphasis-markers)))

  (setq org-directory (concat (getenv "HOME") "/OneDrive - University of Illinois - Urbana/OrgRoamNotes"))
#+end_src

By default org mode displays emphasis markers. The keybinding =C-c s e= toggles them on/off.

*** UI Changes

Now we make org document look nicer in org mode by changing the way the heading markers look and placing margins on each side of the text.

**** Mixed Pitch
=mixed-pitch-mode= allows using both fixed pitch and variable pitch fonts in org mode. It automatically changes the fonts so tables and source code blocks use the fixed-pitch font while all other text uses the variable pitch font. I enable mixed pitch mode in all text modes.

#+begin_src emacs-lisp
  (use-package mixed-pitch
    :hook
    ;; If you want it in all text modes:
    (text-mode . mixed-pitch-mode))
#+end_src

#+RESULTS:
| mixed-pitch-mode | text-mode-hook-identify |

**** Org Bullets

=org-bullets= replaces the standard "*" in headings with unicode characters.

#+name: use-package-org-bullets
#+begin_src emacs-lisp
  ;; make headings in orgmode look nicer
  (use-package org-bullets
    :after org
    :hook (org-mode . org-bullets-mode))
#+end_src

**** Visual Fill Column

=visual-fill-column= adds margins to both sides of the text as I type.

#+name:use-package-visual-fill-column
#+begin_src emacs-lisp

  (defun ska/org-mode-visual-fill ()
    "Pads both sides of text buffer (looks more like a word processor)"
    (setq visual-fill-column-width 100
          visual-fill-column-center-text t)
    (visual-fill-column-mode 1))

  ;; add padding to sides of buffer
  (use-package visual-fill-column
    :after org
    :hook (org-mode . ska/org-mode-visual-fill))
#+end_src

**** HTMLize
htmlize allows syntax highlighting of code blocks when exporting org files to HTML.

#+name:use-package-htmlize
#+begin_src emacs-lisp
  (use-package htmlize)
#+end_src

*** Org Babel

Org Babel is included as part of org mode (as of the latest version) and it allows running code blocks included in Org files as well as exporting code blocks in an org file to an external source file (which is how I am constructing the init.el file from this org file).

First we tell org-mode to not ask for confirmation every time we try to evaluate a code block.

#+begin_src emacs-lisp
  (setq org-confirm-babel-evaluate nil)
#+end_src

Now we enable the languages that we want org babel to understand/execute.

#+name:set-org-babel-langs
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (shell . t)
     (python . t)))
#+end_src

Having org automatically open code source blocks is also really useful.

#+begin_src emacs-lisp
  (require 'org-tempo)
  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
#+end_src

To auto-insert a code block, type =<...= and replace "..." with one of the language codes specified in the code block above (i.e., type =<el= [ =<tab>= ] to create an emacs lisp code block).

** Org Roam

Org Roam is a note taking framework that allows implementing the Zettelkasten method of notetaking. Notes are organized as nodes that can be linked together.

#+name: use-package-org-roam
#+begin_src emacs-lisp
    ;; allows creating new node on page without opening it (stay on same file after inserting link to new file)
  (defun org-roam-node-insert-immediate (arg &rest args)
    (interactive "P")
    (let ((args (cons arg args))
          (org-roam-capture-templates (list (append (car org-roam-capture-templates)
                                                    '(:immediate-finish t)))))
      (apply #'org-roam-node-insert args)))

  (use-package org-roam
    :after org
    :ensure t
    :init
    ;; suppress v2 upgrade warning
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename org-directory))
    (org-roam-completion-everywhere t)
    :config
    (cl-defmethod org-roam-node-type ((node org-roam-node))
      "Return the TYPE of NODE."
      (condition-case nil
          (capitalize
           (file-name-nondirectory
            (directory-file-name
             (file-name-directory
              (file-relative-name (org-roam-node-file node) org-roam-directory)))))
        (error "")))

    (setq org-roam-node-display-template (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode)
    ;; creating capture templates for org-roam notes
    ;; source: https://jethrokuan.github.io/org-roam-guide/
    (setq org-roam-capture-templates
          '(("i" "Idea" plain "%?"
             :if-new (file+head "idea/$%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n#+author: Shayan Azmoodeh\n#+filetags: :idea:\n")
             :immediate-finish t
             :unarrowed t)
            ("r" "Reference Material")
            ("rr" "Paper / Website" plain "%?"
             :if-new (file+head "reference/paper/$%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n#+author: Shayan Azmoodeh\n#+filetags: :reference:\n")
             :immediate-finish t
             :unarrowed t)
            ("rc" "Course Notes (lecture, textbook, etc.)" plain "%?"
             :if-new (file+head "reference/course/%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n#+author: Shayan Azmoodeh\n#+filetags: :reference:\n")
             :immediate-finish t
             :unarrowed t)
            ("a" "Article" plain "%?"
             :if-new (file+head "articles/$%<%Y%m%d%H%M%S>-${slug}.org"
                                "#+title: ${title}\n#+author: Shayan Azmoodeh\n#+filetags: :article:\n")
             :immediate-finish t
             :unarrowed t)))
    :bind (("C-c n f" . org-roam-node-find)
           ("C-c n r" . org-roam-node-random)
           ("C-c n i" . org-roam-node-insert)
           ("C-c n I" . org-roam-node-insert-immediate)
           ("C-c n t" . org-roam-tag-add)
           :map org-mode-map
           ("C-M-i" . completion-at-point)))

#+end_src

The =org-roam-node-type= function allows Emacs to print the folder in which the note is contained as I browse through my nodes in =org-roam-node-find=.

*** Deft

Deft allows searching documents in the given =deft-directory= by their contents (not just by title or tags). Very useful when used with =org-roam= to find notes.

Deft has been configured below to work specifically with =org-roam=.

#+name: use-package-deft
#+begin_src emacs-lisp
  (use-package deft
    :after org
    :config
    (setq deft-directory org-directory
          deft-recursive t
          deft-strip-summary-regexp ":PROPERTIES:\n\\(.+\n\\)+:END:\n"
          deft-use-filename-as-title nil)
    :bind
    ("C-c n d" . deft))
#+end_src
*** Org Roam UI

Since Org Roam allows us to create links between our notes, it would be nice to visualize those connections. Org Roam UI lets us do this by displaying our notes as nodes in a graph, where an edge between two notes indicates that there is a link between them.

The web interface also lets you view the content of the notes as well.

The package requires simple-httpd and websocket to work since it opens a web interface. It also (obviously) requires =org-roam=.

#+name:use-package-org-roam-ui
#+begin_src emacs-lisp

  ;; dependencies for org-roam-ui
  (use-package websocket)
  (use-package simple-httpd)


  (use-package org-roam-ui
    :after websocket simple-httpd org-roam
    :bind (
           ("C-c n u i" . org-roam-ui-open)))
#+end_src

** Reference Management - Must go after Org config
Section must go after the org section because it uses the =org-directory= that is defined in that section.

References are managed through a bibtex file, so we configure bibtex editing in Emacs first.

#+begin_src emacs-lisp
  (setq bibtex-user-optional-fields '(("keywords" "Keywords to describe the entry" "")
                                      ("file" "Link to document file." ":"))
        bibtex-align-at-equal-sign t)
#+end_src

Entries in the bibtex file are searched with =ivy-bibtex=, so the file must be put into the =bib-files-directory= or else it will not be found.

#+begin_src emacs-lisp
(setq bib-files-directory (directory-files org-directory t "^[A-Z|a-z].+.bib")
      pdf-files-directory (concat (getenv "HOME") "/OneDrive - Univesity of Illinois - Urbana/Papers"))
#+end_src

*Change these directories as neccessary*.

*** Ivy Bibtex

Since we're using =ivy-bibtex=, we need to install/configure it.

#+name:use-package-ivy-bibtex
#+begin_src emacs-lisp
  (use-package ivy-bibtex
    :after ivy
    :config
    (setq bibtex-completion-bibliography bib-files-directory
          bibtex-completion-library-path pdf-files-directory
          bibtex-completion-pdf-field "File"
          bibtex-completion-notes-path org-directory
          bibtex-completion-additional-search-fields '(keywords))
    :bind
    (("C-c b" . ivy-bibtex)))
#+end_src

*** Citar

Citar is another helpful package for managing and inserting references/citations into documents.

#+name:use-package-citar
#+begin_src emacs-lisp
  (use-package citar
    :after org ;; depends on org-directory
    :bind (("C-c n b" . citar-insert-citation)
           :map minibuffer-local-map
           ("M-b" . citar-insert-preset))
    :custom
    (citar-bibliography (concat (file-truename org-directory) "/biblio.bib")))
#+end_src

Note citar also needs the path to the bibliography so *update the path if it changes*. It should really only need to be updated if the filename changes because the rest of the path is dependent on the =org-directory=.

** EShell
Eshell provides a linux terminal emulator in Emacs written entirely in emacs lisp. Note that this causes some commands to be slower than they normally would be in a regular linux shell.

#+name: use-package-eshell
#+begin_src emacs-lisp :results none
  (defun ska/configure-eshell ()
    ;; Save command history when commands are entered
    (add-hook 'eshell-pre-command-hook 'eshell-save-some-history)

    ;; Truncate buffer for performance
    (add-to-list 'eshell-output-filter-functions 'eshell-truncate-buffer)

    ;; Bind some useful keys for evil-mode
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "C-r") 'counsel-esh-history)
    (evil-define-key '(normal insert visual) eshell-mode-map (kbd "<home>") 'eshell-bol)
    (evil-normalize-keymaps)

    (setq eshell-history-size         10000
          eshell-buffer-maximum-lines 10000
          eshell-hist-ignoredups t
          eshell-scroll-to-bottom-on-input t))

  ;; eshell comes with Emacs. This allows us to configure it
  (use-package eshell
    :hook (eshell-first-time-mode . ska/configure-eshell)
    :config
    (with-eval-after-load 'esh-opt
      (setq eshell-destroy-buffer-when-process-dies t)
      (setq eshell-visual-commands '("htop" "zsh" "vim")))
    (eshell-git-prompt-use-theme 'robbyrussell))
#+end_src

*** Git Prompt
The =eshell-git-prompt= package displays the git info (i.e., current branch) next to the terminal prompt.

#+name: use-package-eshell-git-prompt
#+begin_src emacs-lisp :results none
  (use-package eshell-git-prompt
    :after eshell)
#+end_src

* Custom Functions
** Org
*** Org Babel

I configured org to automatically tangle my init.org file whenever I save it.

#+begin_src emacs-lisp
  ;; automatically tangle emacs config org file when saving
  (defun ska/org-babel-tangle-config ()
    "Tangle code in org file when the file is saved if the file is the Emacs config file"
    (when (string-equal (buffer-file-name)
                        (file-truename "~/.emacs.d/init.org"))
      (let ((org-confirm-babel-evaluate nil))
        (org-babel-tangle))))
  (add-hook 'org-mode-hook (
                            lambda () (add-hook 'after-save-hook #'ska/org-babel-tangle-config)))
#+end_src
*** Org Roam
Given that we have a large file of references (a .bib file) we want a way to take notes on them and dedicate a note to a chosen reference. The following function allows me to do this.
It also makes use of my org-roam capture template.

#+begin_src emacs-lisp
  ;; source: https://jethrokuan.github.io/org-roam-guide/
  (defun ska/org-roam-node-from-cite (keys-entries)
    "Create an org roam node from the Citar bibliography."
    (interactive (list (citar-select-ref :multiple nil :rebuild-cache t)))
    (let ((title (citar--format-entry-no-widths (cdr keys-entries)
                                                "${author editor} :: ${title}")))
      (org-roam-capture- :templates
                         '(("rr" "reference" plain "%?" :if-new
                            (file+head "reference/paper/${citekey}.org"
                                       ":PROPERTIES:
  :ROAM_REFS: [cite:@${citekey}]
  :END:
  ,#+title: ${title}\n#+author: Shayan Azmoodeh\n#+filetags: :reference:\n")
                              :immediate-finish t
                              :unnarrowed t))
                           :info (list :citekey (car keys-entries))
                           :node (org-roam-node-create :title title)
                           :props '(:finalize find-file))))

#+end_src
** Miscellaneous

Emacs doesn't have a built in function to delete the file in the current buffer so I implemented one (with help from [[https://emacsredux.com/blog/2013/04/03/delete-file-and-buffer/][this blog]]).
The function below simply deletes the file in buffer that you are currently on (if the current buffer contains a file) and also kills the buffer. If the current buffer doesn't contain a file, it just gives a message saying so.

#+begin_src emacs-lisp
  (defun ska/delete-file-and-buffer ()
    "Deletes file open in current buffer and kills window
  if the current buffer contains a file"
    (interactive)
    (let ((filename (buffer-file-name)))
      (if filename ; if curr buff contains a file
          (progn (if (vc-backend filename) ; if version control contains the file
                     (vc-delete filename)
                   (delete-file filename))
                 (message "Deleted file %s" filename)
                 (kill-buffer))
        (message "Current buffer does not contain a file"))))
#+end_src
* Custom Language Formatting

Not sure how the code here works... but it works. I'll figure it out later.

** C Formatting

#+name:set-custom-c-lang-formatting
#+begin_src emacs-lisp
  ;;; customized C indent formatting

  (setq-default c-indent-tabs-mode t     ; Pressing TAB should cause indentation
                c-indent-level 2         ; A TAB is equivilent to two spaces
                c-argdecl-indent 0       ; Do not indent argument decl's extra
                c-tab-always-indent t
                backward-delete-function nil) ; DO NOT expand tabs when deleting
  (c-add-style "my-c-style" '((c-continued-statement-offset 2))) ; If a statement continues on the next line, indent the continuation by 4
  (defun my-c-mode-hook ()
    (c-set-style "my-c-style")
    (c-set-offset 'substatement-open '0) ; brackets should be at same indentation level as the statements they open
    (c-set-offset 'inline-open '+)
    (c-set-offset 'block-open '+)
    (c-set-offset 'brace-list-open '+)   ; all "opens" should be indented by the c-indent-level
    (c-set-offset 'case-label '+)
    (setq c-basic-offset 2))       ; indent case labels by c-indent-level, too
  (add-hook 'c-mode-hook 'my-c-mode-hook)
  (add-hook 'c++-mode-hook 'my-c-mode-hook)
#+end_src

** Java Formatting

#+name:set-custom-java-lang-formatting
#+begin_src emacs-lisp
  ;;; customized Java indent formatting

  (setq c-default-style
        '((java-mode . "ellemtel")))
  (add-hook 'java-mode-hook (lambda ()
                              (setq c-basic-offset 4)
                              tab-width 4))
#+end_src
